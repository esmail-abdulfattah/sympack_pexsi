C***********************************************************************
C***********************************************************************
C*********      elmtra ..... QUOTIENT GRAPH transformation     *********
C***********************************************************************
C***********************************************************************
C
C   PURPOSE:
C       THIS SUBROUTINE performs the quotient graph transformation
c       caused by the elimination of enode.  enode's elimination clique
c       was computed earlier by routine elmclq in array ecliq(*).
c
C
C   NOTES:
C       IT USES HASHING TO DETECT SUPERNODES.
C
C   INPUT PARAMETERS:
C       ENODE       -   NODE to be ELIMINATED.
C       NEQNS       -   NUMBER OF EQUATIONS.
C       ADJLEN      -   LENGTH OF THE ADJACENCY STRUCTURE (ADJNCY(*)).
C                       ideally AT LEAST NEQNS GREATER THAN INITIAL
C                       XADJ(NEQNS+1)-1.
C       MAXINT      -   MAXIMUM INTEGER VALUE WITH WHICH VERTICES CAN
C                       BE MARKED (SEE MARKER(*)).
c       nnodes      -   number of nodes in enode's elimination clique.
c       ecliq(*)    -   array of length neqns, contains enode's  
c                       elimination clique.
C       INVP(*)     -   ARRAY OF LENGTH NEQNS.
C                       ELIMINATED: -NUM, WHERE NUM IS THE NUMBER
C                       ASSIGNED BY THE ELIMINATION ORDER.
C
C   MODIFIED PARAMETERS:
C       TAG         -   VALUE USED TO MARK VERTICES, GENERALLY TO
C                       REGULATE AGAINST PROCESSING THE SAME VERTEX
C                       TWICE.
C       XADJ(*)     -   ARRAY OF LENGTH NEQNS+1, CONTAINING POINTERS
C                       INTO the quotient graph.
C       ADJNCY(*)   -   ARRAY OF LENGTH ADJLEN, CONTAINING A CHANGING
C                       quotient graph.
C       NVTXS(*)    -   ARRAY OF LENGTH NEQNS.
C                       ACTIVE ELIMINATED: NUMBER OF VERTICES IN THE
C                       ELIMINATION CLIQUE.
C                       MERGED ELIMINATED: -1.
C                       UNELIMINATED: NUMBER OF UNELIMINATED VERTEX
C                       NEIGHBORS IN CURRENT QUOTIENT GRAPH.
C                       ABSORBED: -1.
C       WORK(*)     -   ARRAY OF LENGTH NEQNS.
C                       ACTIVE ELIMINATED: not used in this case.
C                       UNELIMINATED: NUMBER OF ELIMINATION CLIQUES 
C                       VERTEX IS ADJACENT TO IN THE QUOTIENT GRAPH.
C                       ABSORBED: MAPS ABSORBED VERTEX TO MINUS THE
C                       ABSORBING VERTEX (I.E., -ABSORBEE).
C       QSIZE(*)    -   ARRAY OF SIZE NEQNS.
C                       ELIMINATED: not used at this time.
C                       UNELIMINATED AND NOT IN ENODE'S ELIMINATION
C                       CLIQUE: SUPERNODE SIZE.
C                       UNELIMINATED AND IN ENODE'S ELIMINATION
C                       CLIQUE: NEGATIVE OF SUPERNODE SIZE.  CHANGED
C                       BACK TO POSITIVE AT END OF ROUTINE.
C                       ABSORBED: 0.
C       MARKER(*)   -   ARRAY OF LENGTH NEQNS, USED TO MARK PREVIOUS
C                       VISITS TO VERTICES.
C                       NOT ABSORBED: < MAXINT.
C                       ABSORBED: MAXINT.
C       ECHEAD      -   HEAD OF ELIMINATION CLIQUE LIST.
C       ECTAIL      -   TAIL OF ELIMINATION CLIQUE LIST.
C       ECFORW(*)   -   ARRAY OF SIZE NEQNS.
C                       FORWARD LINKS OF A LIST OF THE ELIMINATION 
c                       CLIQUES ORDERED BY THE ELIMINATION.
C                       OTHERWISE: -1.
C       NXTLOC      -   POINTS TO FIRST LOCATION IN VACANT STORAGE
C                       REMAINING AT END OF ADJACENCY STRUCTURE
C                       (ADJNCY(*)).
c       gbgcnt      -   number of garbage collections performed on the
c                       quotient graph data structure.
C       CLQSIZ      -   ACTUAL SIZE OF THE CLIQUE GENERATED BY ENODE'S
C                       ELIMINATION.  It is correct on input, and is 
c                       modified by any mass elimination.
C       umark(*)    -   ARRAY OF LENGTH NEQNS, USED for marking during
c                       Wing-Huang marking processes.
C                       NOT ABSORBED: < MAXINT.
C                       ABSORBED: MAXINT.
C
C    WORKING PARAMETERS:
c       hheads      -   array of size neqns.
c                       heads of the lists used for hashing.
C       hlink(*)    -   ARRAY OF LENGTH NEQNS.
C                       FORWARD LINK IN hash LISTs (>=0).
c       
C
C***********************************************************************
C
      SUBROUTINE  compress_skel2
     &                    ( NEQNS , ADJLEN, snode , invp  ,
     &                      xskadj, sklenf, sklenb, skadj ,
     &                      rep   ,
     &                      MARKER,
     &                      hheads, hlink                   )
C
C       -----------
C       PARAMETERS.
C       -----------
        INTEGER             ADJLEN,
     &                      NEQNS

        INTEGER             
     &                      invp(neqns)   ,
     &                      rep(neqns)    ,
     &                      skadj(ADJLEN) ,
     &                      sklenf(neqns) ,
     &                      sklenb(neqns) ,
     &                      snode(neqns)  ,
     &                      hheads(neqns) , 
     &                      hlink(neqns)  ,
     &                      MARKER(NEQNS) ,
     &                      xskadj(neqns+1)
C
C       ----------------
C       LOCAL VARIABLES.
C       ----------------
        LOGICAL             MATCH

        integer*8           hash  , neqns8

        INTEGER             
     &                      hash2 , iloc  , INODE ,
     &                      JNODE ,
     &                      K     , KNODE , KSTART, KSTOP,
     &                      newi  , newj  , newk
C
C***********************************************************************
C
c       --------------------------------------------
c       long integer version of number of equations.
c       --------------------------------------------
        neqns8 = neqns
c
C       ******************************
C       graph compression VIA HASHING.
C       ******************************

c       -------------------------------------
c       initialize empty hash lists.
c       hheads(i) is the head of hash list i.
c       -------------------------------------
        do  inode = 1, neqns
            hheads(inode) = 0
            marker(inode) = 0
            rep(inode) = inode
        end do
C       --------------------------
C       FOR EVERY VERTEX INODE ...
C       --------------------------
        DO  INODE = 1, neqns
c           print *,' '
c           print *,'inode:',inode
            newi = invp(inode)
C           --------------------------------------------
C           MARK THE skeleton "back" NEIGHBORS OF INODE.
c           (and compute its hash value.)
C           --------------------------------------------
            hash = 0
            if  ( sklenb(inode) .eq. 0 )  go to 200
            KSTART = xskadj(INODE+1) - 1
            KSTOP = xskadj(Inode+1) - sklenb(inode)
            DO  K = KSTART, KSTOP, -1
                KNODE = skadj(K)
c               print *,'    knode:',knode
                hash = hash + knode
                MARKER(KNODE) = inode
            end do
            hash2 = mod ( hash, neqns8 ) + 1
c           print *,'hash,hash2:',hash,hash2
C           ------------------------------------------------
C           SCAN THE NODES JNODE already IN inode's HASH BIN
C           FOR IDENTICAL skeleton ADJACENCY SETS.
C           ------------------------------------------------
c           -------------------------------------------
c           for each node jnode in inode's hash bin ...
c           -------------------------------------------
            jnode = hheads(hash2)
  100       continue
            IF  ( JNODE .GT. 0 )  THEN
C               -----------------------------------------------------------
C               IF LIST LENGTHS and supernodes OF INODE AND JNODE MATCH ...
C               -----------------------------------------------------------
c               print *,' '
c               print *,'    jnode:',jnode
                newj = invp(jnode)
                MATCH = .FALSE.
c               print *,'    snodej,snodei:',
c    &                  snode(newj),snode(newi)
c               print *,'    lenj,leni:',
c    &                  sklenb(jnode),sklenb(inode)
                IF  ( snode(newj) .eq. snode(newi) .and.
     &                sklenb(jnode) .eq. sklenb(inode)     )  then
c                   print *,'YES'
C                   ------------------
C                   CHECK FOR A MATCH.
C                   ------------------
                    MATCH = .TRUE.
                    KSTART = xskadj(jnode+1) - 1
                    KSTOP = xskadj(jnode+1) - sklenb(jnode)
                    DO  K = KSTART, KSTOP, -1
                        KNODE = skadj(K)
c                       print *,'        knode:',knode
                        IF  ( MARKER(KNODE) .NE. inode )  THEN
                            MATCH = .FALSE.
                        ENDIF
                    end do
                ENDIF
C               ----------------------------
C               IF INODE AND JNODE MATCH ...
C               ----------------------------
                IF  ( MATCH )  THEN
C                   ----------------------------------
C                   INODE WILL BE ABSORBED INTO JNODE.
C                   ----------------------------------
                    rep(newi) = newj
c                   print *,'inode ',newi,' absorbed into ',newj
c                   -------------------
c                   inode is absorbed.
c                   skip to next inode.
c                   -------------------
                    go to 200
                ENDIF
c               -----------------------------
c               try next jnode in hash bin.
c               hlink(jnode) is forward link.
c               -----------------------------
                jnode = hlink(jnode)
                go to 100
            ENDIF
c           ------------------------------------
c           inode will be a representative node.
c           insert it into its hash list.
c           hlink(inode) is forward link.
c           ------------------------------------
            hlink(inode) = hheads(hash2)
            hheads(hash2) = inode
  200       CONTINUE
        end do
c
c       ********************************************
c       now compress the skeleton "forward" lists by
c       removing the nodes that have been absorbed.
c       ********************************************
C
C       --------------------------
C       FOR EVERY VERTEX INODE ...
C       --------------------------
        DO  INODE = 1, neqns
            if  ( sklenf(inode) .eq. 0 )  go to 300
            iloc = xskadj(inode)
            kstart = iloc
            kstop = iloc + sklenf(inode) - 1
c           -----------------------------------------------
c           for every "forward" skeleton neighbor knode ...
c           -----------------------------------------------
            do  k = kstart, kstop
                knode = skadj(k)
                newk = invp(knode)
                if  ( rep(newk) .eq. newk )  then
c                   ----------------------------------------------------
c                   keep knode in inode's list if it is a representative
c                   node (unabsorbed).
c                   ----------------------------------------------------
                    skadj(iloc) = knode
                    iloc = iloc + 1
                end if
            end do
c           ------------------------------------
c           record new length of list for inode.
c           ------------------------------------
            sklenf(inode) = iloc - xskadj(inode)
  300       continue
        end do
c
        RETURN
      END
